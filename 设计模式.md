# javascript 设计模式

设计模式：解决一类问题的嗯最佳方案。

遵循的一条原则：找出程序中变化的地方，将其封装起来，以实现复用。

> 动态语言和鸭子类型

鸭子类型：只关注对象的行为，而不是对象本身，即一个对象看起来像鸭子，走路像鸭子，它就是鸭子。

动态语言的一个原则：面向接口编程，而不是面向实现。比如，一个对象实现了 pop 和 push 方法，只要实现正确，就可把该对象当成栈来使用。

> 多态

多态的实际含义是：同一操作作用于不同的对象上面，可以产生不同的解释和不同的执行结果。换句话说，给不同的对象发送同一个消息的时候，这些对象会根据这个消息分别给出不同的反馈。

使用继承来得到多态效果，是让对象表现出多态性的最常用手段。继承通常包括实现继承和接口继承。

静态语言实现多态，通常是向上转型，即参数的类型设置为一个更为广泛的类型，调用时传递一个具体的类型。动态语言由于不存在类型约束，并不需要这种技术。

多态的最根本好处在于，你不必再向对象询问“你是什么类型”而后根据得到的答案调用对象的某个行为——你只管调用该行为就是了，其他的一切多态机制都会为你安排妥当。换句话说，多态最根本的作用就是通过把过程化的条件分支语句转化为对象的多态性，从而消除这些条件分支语句。

在 JavaScript 这种将函数作为一等对象的语言中，函数本身也是对象，函数用来封装行为并且能够被四处传递。当我们对一些函数发出“调用”的消息时，这些函数会返回不同的执行结果，这是“多态性”的一种体现，也是很多设计模式在 JavaScript 中可以用高阶函数来代替实现的原因。

> 封装

封装的目的：隐藏信息。

封装数据、封装实现、封装类型和封装变化。

封装数据，限制数据的访问权限。

封装实现：将函数的实现封装起来，对外提供接口，接口的使用者并不关系实现细节，只关注接口功能是否正确，可随意修改内部实现。封装实现降低了对象之间程度。

封装类型：静态语言中，封装类型是一种重要的封装方式。一般而言，封装类型是通过接口和类进行的。把对象的真正类型隐藏在抽象类或者接口之后，相比对象的类型，客户更关心对象的行为。JavaScript 的类型是模糊的，没能力做更多，也没必要做更多。

封装变化：找到程序中变化的部分，封装它们。

通过封装变化的方式，把系统中稳定不变的部分和容易变化的部分隔离开来，在系统的演变过程中，我们只需要替换那些容易变化的部分，如果这些部分是已经封装好的，替换起来也相对容易。这可以最大程度地保证程序的稳定性和可扩展性。

## 原型模式

原型模式不单是一种设计模式，也被称为一种编程泛型。

原型模式是通过克隆来创建对象的，那么很自然地会想到，如果需要一个跟某个对象一模一样的对象，就可以使用原型模式。

```js
var Plane = function () {
  this.blood = 100
  this.attackLevel = 1
  this.defenseLevel = 1
}

var plane = new Plane()
plane.blood = 500
plane.attackLevel = 10
plane.defenseLevel = 7

var clonePlane = Object.create(plane)
console.log(clonePlane.blood) //输出500
console.log(clonePlane.attackLevel) //输出10
console.log(clonePlane.defenseLevel) //输出7
```

create 在不支持的浏览器中的实现：

```js
Object.create =
  Object.create ||
  function (obj) {
    var F = function () {}
    F.prototype = obj

    return new F()
  }
```

面试题：`new Object`、`Object.create`和`const a = {}`的区别？

`new Object`调用构造函数创建对象，添加的属性在自身实例下，修改的属性影响原始对象。
`{}`使用字面量创建对象，和`new Object`一样。

`Object.create`继承一个对象，添加的属性在原型上（第一个参数），修改的属性不影响原始对象。

```js
const person = { name: 'JACK', age: 23 }
const b = new Object(person)
console.log(b)
console.log(Object.getPrototypeOf(b) === b.__proto__) // true
console.log(Object.getPrototypeOf(b) === Object.prototype) // true
// 修改属性
b.name = 'JACK Chou'
console.log(b)
console.log(person) // 原始对象的属性也被修改
console.log(person === b) // true

const Jack = { name: 'Jack', age: 20 }

const c = Object.create(Jack)
console.log(c) // {}
console.log(c === Jack) // false
console.log(Object.getPrototypeOf(c)) // {name:'Jack',age: 20}
console.log(Object.getPrototypeOf(c) === Object.prototype) // false
c.city = 'GuiYang' // 添加属性，不影响原始对象
console.log(Jack)
console.log(c)

console.log('********************************')
const d = new Object() //{}
console.log(Object.getPrototypeOf(d) === d.__proto__) // true
console.log(Object.getPrototypeOf(d) === Object.prototype) // true
```

## this call apply

`this` 总是指向一个对象，而具体指向哪个对象，在代码执行是才能确定，而不是声明时。

### this 指向

5 种情况：

1. 作为对象方法调用

```js
var obj = {
  a: 1,
  getA: function () {
    alert(this === obj) // 输出：true
    alert(this.a) // 输出： 1
  },
}

obj.getA()
```

2. 作为普通函数调用

```js
window.name = 'globalName'

var myObject = {
  name: 'sven',
  getName: function () {
    return this.name
  },
}

var getName = myObject.getName
console.log(getName()) // globalName
```

3. 构造函数

当用 new 运算符调用函数时，该函数总会返回一个对象，通常情况下，构造器里的 this 就指向返回的这个对象。

```js
var MyClass = function () {
  this.name = 'sven'
}

var obj = new MyClass()
alert(obj.name) // 输出：sven
```

用 new 调用构造器时，还要注意一个问题，如果构造器显式地返回了一个 object 类型的对象，那么此次运算结果最终会返回这个对象，而不是我们之前期待的 this。

```js
var MyClass = function () {
  this.name = 'sven'
  return {
    // 显式地返回一个对象
    name: 'anne',
  }
}

var obj = new MyClass()
alert(obj.name) // 输出：anne
```

构造器不显式地返回任何数据，或者是返回一个非对象类型的数据，就不会造成上述问题。

```js
var MyClass = function () {
  this.name = 'sven'
  return 'anne' // 返回string类型
}

var obj = new MyClass()
alert(obj.name) // 输出：sven
```

4. call、bind、apply

显示地指定 this。

this 丢失问题：

```js
const getById = document.getElementById
getById('app') // Uncaught TypeError: Illegal invocation
```

> document.getElementById 内部使用到了 this,指向 document，赋值给另一个变量后，this 不再指向 document。

解决办法，使用 apply 绑定 this。

```js
document.getElementById = (function (func) {
  return function () {
    return func.apply(document, arguments)
  }
})(document.getElementById)

var getId = document.getElementById
var div = getId('div1')
alert(div.id) // 输出： div1
```

apply、call 的第一个参数为 this 对象，apply 的第二个参数为数组，call 的第二个参数数量不固定。第一个参数为 null，指向全局对象，在严格模式下，this 还是为 null。

除了改变 this 的指向，apply 和 call 还能用于`借用方法`。

借用构造函数，实现继承效果。

```js
var A = function (name) {
  this.name = name
}

var B = function () {
  A.apply(this, arguments) // 借用 A
}

B.prototype.getName = function () {
  return this.name
}

var b = new B('sven')
console.log(b.getName()) // 输出： 'sven'
```

5. 箭头函数

由外层包裹函数的 this 决定。

6. 事件处理器

绑定事件的元素

```js
const btn = document.querySelector('#btn')
btn.addEventListener('click', function () {
  console.log(this) // btn 元素
})
```
