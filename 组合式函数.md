# 如何更好的使用组合式函数写 hook

组合式函数是 vue3 带来的重大特性，是组织 vue 组件代码的新方式，关于它的好处，网上已经有很多文章阐述了，本文主要阐述它如何解决 vue2 难以复用状态逻辑的问题。

## vue2 复用状态逻辑的方式

在讨论具体的方式之前，先看看状态和状态逻辑的区别。

> 状态 vs 状态逻辑

状态即组件状态：影响组件 UI 层的数据，可理解成 props 和 state，往往是变量，是数据，不含函数逻辑。为何说往往？有时候函数也可以作为 prop 传入组件，较少。

状态逻辑：携带组件状态的**函数**，这些函数比较特殊，其执行结果会影响组件 UI，能在组件之间**复用**。

[更多讨论](https://stackoverflow.com/questions/27991366/what-is-the-difference-between-state-and-props-in-react)

> vue2 复用状态逻辑的方式

1. mixin

2. extends

> mixin 在插件中用得比较多，比如 vuex 全局混入状态。

> extends 可复用逻辑、状态和模板。

这两种方式都不好，滥用会导致命名冲突，代码难以理解，数据来源难以追踪。

3. renderProp

4. renderLess

> 复用逻辑、状态和模板。

比 1、2 好点，使用得当，可让组件易扩展、易使用，好理解。

5. provide inject

这在常规的项目开发中，很少用到，使用多了，会让组件变得强耦合，数据来源难以追踪。

> 复用状态、逻辑，在 vue 插件使用得多。

6. 将函数或者属性绑定到 vue 原型上

没有严重的缺点，主要复用逻辑，比如挂载 http 请求函数。

### vue2 复用状态逻辑的问题

- 状态和 this 绑定了，导致复用困难

3 和 4 的方式，可使得状态脱离 this，非常强大，我非常喜欢这两种方式，但根据个人经验，vue2 的用户中，熟悉这两种的较少。

- 不能单独测试，需要依赖组件

在 vue3 中，1、2、6 的方式基本可以不用了。

- 状态来源难以追踪

- 命名冲突

- 类型支持弱

> 总之，问题比较多。

## vue3 组合函数编写方式有哪些？or 如何设计组合函数？

vue3 的组合式函数解决 vue2 中复用状态逻辑的问题。

组合式函数的优点

1. 状态不再和 this 绑定，独立于组件，可单独测试

2. 状态之间的依赖关系更加清晰，容易调试

3. 都是函数，可灵活组合，可从是否为纯函数的角度考虑

4. 类型支持好

参考 react hook 的写法，使用 use 作为组合函数的前缀。

### 状态和逻辑如何连接的？

> setup 函数在组件创建时**只执行一次**，并建立状态（数据）和逻辑（函数），状态和模板之间的连接。

有一 useAdd 组合函数：

`hooks.ts`

```ts
export function useAdd(a: MaybeRef<number>, b: MaybeRef<number>) {
  log()
  return computed(() => unref(a) + unref(b))
}

function log() {
  console.log('useAdd')
}
```

在组件使用：

```html
<template>
  <div>
    <p>c:{{ c }}</p>
    <button type="button" @click="b = 100">修改b</button>
  </div>
</template>

<script>
  import { useAdd } from './hooks'
  export default {
    setup() {
      const a = 1
      const b = ref(10)
      const c = useAdd(a, b)
      return { b, c }
    },
  }
</script>
```

setup 函数在组件创建时执行一次，useAdd 也执行了一次，a、b、c 之间就建立了关系，当修改 b 时，即使函数 useAdd 不会重新执行，c 也会变化。**log**函数在 b 修改时，并没只执行。

在单独的 js 中运行组合函数，也会建议这样的依赖关系。

`testUseAdd.js`:

```js
import { useAdd } from './hooks'

let a = 10
const b = ref(20)
const c = useAdd(a, b)
console.log(c.value) // 30
setTimeout(() => {
  a = 100
  b.value = 1000
  console.log('setTimeout') // 修改 b
  console.log(c.value) // c 变成 1010，而不是 1100
}, 4000)
```

把`testUseAdd.js`引入组件，进行测试：

```html
<script>
  import './testUseAdd'
</script>
```

> **log**函数在 b 修改时，没执行，这点有点费解。

总结：

- 组合函数会在 setup 执行后建立状态之间的连接，即在 setup 中输入和输出建立连接

- 输出会随着输入的变化而变化

- 注意在组合函数中只会执行一次的函数

理解这三点是写好组合函数的关键。

编写组合函数的常见模式或技巧有哪些呢？

### 返回响应式状态

使用组合函数封装一个响应式的 storage。

```js
function getItem(key, storage) {
  const value = storage.getItem(key)
  if (!value) return null
  try {
    return JSON.parse(value)
  } catch (error) {
    return value
  }
}

export function useStorage(key, type = 'session') {
  let storage = null
  switch (type) {
    case 'session':
      storage = sessionStorage
      break
    case 'local':
      storage = localStorage
    default:
      break
  }

  const value = shallowRef(getItem(key, storage))
  function setItem(storage) {
    return newValue => {
      value.value = newValue
      storage.setItem(key, JSON.stringify(newValue))
    }
  }
  return [value, setItem(storage)]
}
```

使用：

```js
const [person, setItem] = useStorage('jack')
```

> 返回的响应式数据，可直接绑定到模板中。

> setItem 用于修改状态，状态被修改了，会响应到模板上。

> 为何要返回一个修改状态的函数？

返回修改函数，使得状态可变化，变化的状态才更加有用。

不接受响应式状态作为参数，只返回响应式状态和修改函数，这种常见于 hook `只执行一次`的情况，即在组件初始化时执行 hook，得到状态，后续不再执行，这类 hook，往往是纯函数。

> 技巧：返回 toRefs 的数据，可使用解构且保持响应性。

> 技巧：返回和响应式数据和在组件内声明的声明的一样：可监听，可用于生成计算属性。

比如：

```js
import { useFetch } from '@vueuse/core'
const { data } = useFetch('https://api.github.com/users/jackchoumine').json()
const avatar = computed(() => data.value?.avatar_url)
```

页面需要展示用户头像，我们可通过计算属性拿到，接口返回后，再计算出用户头像。

### 修改 hook 返回的响应式数据

hook 返回的响应式数据，可在组件里修改，然后出发 hook 内部的逻辑执行。

```ts
import type { MaybeRef } from '@vueuse/core'
export function useTitle(newTitle?: MaybeRef<string>) {
  const title = ref(newTitle)
  watchEffect(() => {
    const _title = title.value || document.title
    document.title = _title
  })
  return title
}
```

使用：

```js
const title = useTitle()
title.value = '修改hook的返回值' // 会触发 useTitle 内的监听器执行
```

再看一个例子：

```html
<script setup name="MyInput">
  const emit = defineEmits(['update:modelValue'])
  defineProps({
    modelValue: {
      type: String,
    },
  })
  function update(event) {
    emit('update:modelValue', event.target.value)
  }
</script>

<template>
  <input type="text" :value="modelValue" @input="update" />
</template>
```

创建一个返回 ref 的函数，代替`value`和`input`事件。

```ts
export function useVModel(props, name) {
  const emit = getCurrentInstance().emit

  return computed({
    get() {
      return props[name]
    },
    set(v) {
      emit(`update:${name}`, v)
    },
  })
}
```

使用`useVModel`改造 MyInput：

```html
<script setup name="MyInput">
  import { useVModel } from '@hooks'
  const emit = defineEmits(['update:modelValue'])
  const props = defineProps({
    modelValue: {
      type: String,
    },
  })
  const value = useVModel(props, 'modelValue')
</script>

<template>
  <!-- NOTE 通过 v-model 修改 useVModel 的返回值 -->
  <input type="text" v-model="value" />
</template>
```

### 输入响应式状态，再返回响应式状态

vue 是副作用驱动的，很多场景下，在某些状态变化时（可理解为副作用的依赖），需要执行副作用，比如发送网络请求，此时可提取 hook, 把依赖作为 hook 的参数。

看一个例子：

```html
<template>
  <div>
    <input type="text" v-model="input" />
    <ul>
      <li v-for="(item, index) in list" :key="index">{{ item.name }}</li>
    </ul>
    <p>{{ input }}</p>
  </div>
</template>

<script setup>
  const input = ref('')

  httpGet()
  watch(input, value => {
    httpGet(value)
  })

  function httpGet(key) {
    http(key).then(res => {
      list.value = res
    })
  }

  // 模拟http请求
  function http(key) {
    return new Promise(resolve => {
      setTimeout(() => {
        let list = [{ name: 'react' }, { name: 'vue' }]
        key && (list = list.filter(item => item.name.includes(key)))
        resolve(list)
      }, 100)
    })
  }
</script>
```

组件的基本功能：拉取后台数据，且用户输入时，再调用接口拉取数据，非常常规的功能。

用户输入`input`是作为 httpGet 执行依赖的，当 input 变化时，执行 httpGet。

如何使用 hook 写出相同的功能？

关键点：如何处理 httpGet 的依赖？将用户输入作为参数。

`hooks.ts`

```ts
import type { Ref } from 'vue'

export function useHttpGet(key: Ref<string>) {
  const list = ref([])
  watch(
    key,
    newKey => {
      http(newKey).then(res => {
        // @ts-ignore
        list.value = res
      })
    },
    { immediate: true }
  )

  return { list }
}

export function http(key) {
  return new Promise(resolve => {
    setTimeout(() => {
      let list = [{ name: 'http', age: 100 * Math.random() }, { name: 'vue' }]
      key && (list = list.filter(item => item.name.includes(key)))
      resolve(list)
    }, 100)
  })
}
```

使用方式：

```html
<template>
  <div>
    <input type="text" v-model="input" />
    <ul>
      <li v-for="(item, index) in list" :key="index">{{ item.name }}</li>
    </ul>
    <p>{{ input }}</p>
  </div>
</template>

<script setup>
  import { useHttpGet } from './hooks'
  const input = ref('')
  const { list } = useHttpGet(input)
</script>
```

使用 hook 之后，代码简洁多了。

> 技巧：使用 `toRef`可从**响应式对象**中属性转成 ref ，ref 和该对象之间会保持值的同步。

### 参数可能是 Ref

希望参数可能是 Ref，从而兼容前两种方式。

再对上面的例子改造：

```ts
import type { Ref } from 'vue'

type MaybeRef<T> = Ref<T> | T

export function useHttpGet(key: MaybeRef<string>) {
  const keyRef = ref(key)
  const list = ref([])
  watch(
    keyRef,
    newKey => {
      http(newKey).then(res => {
        // @ts-ignore
        list.value = res
      })
    },
    { immediate: true }
  )

  return { list }
}
```

`ref` 的参数是 ref，返回 ref，普通数据，就将其包裹成 ref。

> 技巧

可让参数和现有的 ref 建立连接，修改现有 ref，触发 hook 执行。

还是上面 useTitle，可这样使用：

```js
const hello = ref('hello')
const title = computed(() => {
  return hello.value + Math.random() * 10
})
useTitle(title)
setTimeout(() => {
  hello.value = 'Hello'
}, 2000)
```

### 封装第三方库

编写一个按钮，鼠标移入，在右边显示提示信息，使用`popperjs`实现。

常规实现方式：

```html
<template>
  <div>
    <h1>hook 与第三方库</h1>
    <button
      ref="btn"
      @mouseover="onMouseover"
      @mouseout="onMouseout"
      style="background-color: lightgreen; height: 40px; width: 100px">
      按钮
    </button>
    <div
      v-show="isOver"
      ref="tooltip"
      style="background-color: lightyellow; height: 20px; width: 150px">
      tool tip
    </div>
  </div>
</template>

<script setup>
  import { createPopper } from '@popperjs/core'
  const isOver = ref(false)
  function onMouseover() {
    isOver.value = true
  }
  function onMouseout() {
    isOver.value = false
  }
  const btn = ref()
  const tooltip = ref()
  // BUG 位置不对
  onMounted(() => {
    createPopper(btn.value, tooltip.value, {
      placement: 'right',
    })
  })
</script>
```

hook 实现方式：

```html
<template>
  <div>
    <button
      :ref="reference"
      @click="onClick"
      style="background-color: lightgreen; height: 40px; width: 100px">
      use hook
    </button>
    <div
      v-show="isOpen"
      :ref="tooltip"
      style="background-color: lightyellow; height: 20px; width: 150px">
      tool tip
    </div>
  </div>
</template>

<script setup>
  import { usePopper } from './usePopper'
  const isOpen = ref(false)
  function onClick() {
    isOpen.value = !isOpen.value
  }
  const { reference, tooltip } = usePopper('right')
</script>
```

usePopper 的实现：

```js
import { createPopper } from '@popperjs/core'
export function usePopper(placement) {
  const target = ref(null)
  const tooltipDom = ref(null)

  onBeforeUpdate(() => {
    target.value = null
    tooltipDom.value = null
  })

  watchEffect(
    () => {
      createPopper(target.value, tooltipDom.value, {
        placement: placement,
      })
    },
    {
      flush: 'post', // 组件更新后执行回调
    }
  )

  return {
    reference(el) {
      target.value = el
    },
    tooltip(el) {
      tooltipDom.value = el
    },
  }
}
```

知识点：

1. ref 获取模板，支持字符串，也支持函数，函数会在每次组件更新时调用，所以在组件更新之前，将引用设置 null。

> 在循环中使用函数更好，也可以使用字符串。

2. 利用这一特点，从 hook 里返回函数，绑定到 dom 上，把创建 tooltip 的过程封装在 hook 中，可在不同的组件使用。

在加强功能，支持位置动态修改如何办？

把 placement 参数设置响应式数据。

常规实现：

```js
const placement = ref('right')

watchEffect(
  () => {
    createPopper(btn.value, tooltip.value, {
      placement: placement.value,
    })
  },
  {
    flush: 'post',
  }
)
```

> 修改 placement，就会重新创建 tooltip。

hook 实现：

将位置设置为响应数据，作为 hook 的参数。

```js
export function usePopper(placement) {
  const target = ref(null)
  const tooltipDom = ref(null)

  onBeforeUpdate(() => {
    target.value = null
    tooltipDom.value = null
  })

  watchEffect(
    () => {
      createPopper(target.value, tooltipDom.value, {
        placement: unref(placement), // ref 作为参数传入
      })
    },
    {
      flush: 'post',
    }
  )

  return {
    reference(el) {
      target.value = el
    },
    tooltip(el) {
      tooltipDom.value = el
    },
  }
}
```

这样是使用：

```js
const placement = ref('right')
const { reference, tooltip } = usePopper(placement) // 传入ref
```

对比两种方案，hook 的方式更加强大而自由，代码简洁易懂。

## 条件语句下的组合函数

<!-- TODO 待完善 -->

[Conditional Vue.js Compositions](https://logaretm.com/blog/conditional-vuejs-compositions)

## 参考

[vue 组合函数 vs React hook](https://vuejs.org/guide/extras/composition-api-faq.html#comparison-with-react-hooks)

[如何在组合函数中使用 ref](https://logaretm.com/blog/juggling-refs-around/)

## 其他资源

[泛型组件](https://logaretm.com/blog/generically-typed-vue-components/)
